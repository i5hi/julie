use crate::lib::aes;
use crate::lib::hash;
use crate::lib::rsa;

use crate::lib::totp;
use crate::lib::jwt;
use crate::lib::email;
use oath::{HashType};
use std::time::SystemTime;
use serde::{Deserialize, Serialize};
use std::str;
use std::str::FromStr;
use uuid::Uuid;


#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AuthFactor{
    /// ApiKey is factor 0, when a random new uid and apikey are generated by an admin and shared with a client to setup Basic auth.
    ApiKey,
    /// Basic signifies a username:pass256 set by the client (requires ApiKey).
    Email,
    /// Email auth is an alternative to basic auth which requires ada-postfix (requires ApiKey).
    Basic,
    /// Signature signifies a public_key is registered; requiring token requests to be signed by the client (requires Basic). 
    Signature,
    /// Totp is if a b32_key is verified by the client (requires Basic).
    Totp,
    /// All factors enabled.
    All,
}
impl AuthFactor {
    pub fn as_str(&self) -> &'static str {
        match *self {
            AuthFactor::ApiKey=>"ApiKey",
            AuthFactor::Email=>"Email",
            AuthFactor::Basic=>"Basic",
            AuthFactor::Signature=>"Signature",
            AuthFactor::Totp=>"Totp",
            AuthFactor::All=>"All"
        }
    }
}
impl FromStr for AuthFactor{
    type Err = ();

    fn from_str(s: &str) -> Result<AuthFactor,Self::Err>{
        let factor = match s {
            "ApiKey"=>AuthFactor::ApiKey,
            "Email"=>AuthFactor::Email,
            "Basic"=>AuthFactor::Basic,
            "Signature"=>AuthFactor::Signature,
            "Totp"=>AuthFactor::Totp,
            "All"=>AuthFactor::All,
            &_=>return Err(())
        };
        Ok(factor)
    }
}

/// ClientAuth is a database structure to store client authentication data.
//// The current implementation is very tightly coupled with sled db.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientAuth {
    pub uid: String, // index
    pub apikey: String,
    pub salt: String,
    pub username: String,
    pub pass512: String,
    pub email : String,
    pub email_token: String,
    pub email_expiry: u64,
    pub public_key: String,
    pub totp_key: String,
    pub factors: Vec<AuthFactor>,
}

pub enum AuthUpdate{
    ApiKey,
    Salt,
    Username,
    P512,
    Email,
    EmailToken,
    EmailExpiry,
    PublicKey,
    TotpKey,
    Factors
}

pub const EMAIL_TOKEN_LIFETIME: u64 = 600;

impl ClientAuth {
    /// Used by the admin to create a new client with a uid and apikey index.
    pub fn new() -> Self {

        ClientAuth {
            uid: format!("s5uid-{}", Uuid::new_v4()).to_string(),
            apikey: aes::keygen(aes::Encoding::Hex),
            salt: hash::create_salt(),
            email: "None".to_string(),
            email_token: "None".to_string(),
            email_expiry: 0,
            username: "None".to_string(),
            pass512: "None".to_string(),
            public_key: "None".to_string(),
            totp_key: "None".to_string(),
            factors:vec![AuthFactor::ApiKey]
        }
        

    }
    pub fn verify_apikey(&self, uid: &str, apikey: &str)->bool{
        if self.uid == uid && self.apikey == apikey{
            true
        }
        else{
            false
        }
    }
    pub fn verify_basic_auth(&self, basic_auth_encoded: String)->bool{
        let decoded_auth = str::from_utf8(&base64::decode(&basic_auth_encoded).unwrap())
            .unwrap()
            .to_string();
        let parts = decoded_auth.split(":").collect::<Vec<&str>>();
        let username = parts[0];
        let pass512 = hash::salted512(&parts[1], &self.salt);
        
        
        if &pass512 == &self.pass512 && username == &self.username {
             true
        } else {
            false
        }
    }
    pub fn verify_signature(&self, message: &str, signature: &str)->bool{
        rsa::verify(&message, &signature, &self.public_key)
    
    }
    pub fn verify_totp(&self, otp: u64)->bool{
        if totp::generate_otp(self.clone().totp_key, HashType::SHA1)==otp {
            true        
        }
        else{
            false
        }
    }
    pub fn verify_email_token(&self, token: String)->bool{
        let now = match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {
            Ok(n) => n.as_secs(),
            Err(_) => panic!("SystemTime before UNIX EPOCH!"),
        };
    
        if self.factors.contains(&AuthFactor::Email) 
            && self.email_token == token
            && self.email_expiry > now{
                true
            }
        else{
            false
        }
    }
    pub fn send_email_token(&self)->bool{
        let message = format!("https://test.satswala.com/julie/callback?uid={}token={}", &self.uid,&self.email_token);
    
        if email::send(&self.email, "Alias", &message){
            true
        }
        else{
            false
        }
    }

}


// #[cfg(test)]
// mod tests {
//     use super::*;
//     use crate::lib::hash::{sha256,salted512};

//     #[test]
//     fn client_composite() {
//         // client asks admin to initialize a user account
//         let client_auth = ClientAuth::new();
//         // admin gives client this new client_auth with an apikey
//         let indexes = get_uid_indexes();
//         println!("#Clients: {}", indexes.len());
//         println!("{:?}", indexes);

//         // client then registers a username and password
//         let username = "vmd";
//         let password = "secret";
//         // user must hash password
//         let p256 = sha256(password);
//         let pass256_expected =
//             "2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b".to_string();
        
//         assert_eq!(p256.clone(), pass256_expected.clone());

//         // user must encode username:pass256 in base64
//         let encoded = base64::encode(format!("{}:{}",username.clone(),p256.clone()).as_bytes());
//         let encoded_expected = "dm1kOjJiYjgwZDUzN2IxZGEzZTM4YmQzMDM2MWFhODU1Njg2YmRlMGVhY2Q3MTYyZmVmNmEyNWZlOTdiZjUyN2EyNWI=";

//         assert_eq!(encoded.clone(),encoded_expected.clone());
    
//         // println!("{:#?}",client_auth.clone());
//         assert!(client_auth.clone().update(AuthUpdate::Username,username));
//         assert!(client_auth.clone().update(AuthUpdate::P512,&salted512(&p256,&client_auth.clone().salt)));
//         assert!(client_auth.clone().update(AuthUpdate::Factors,AuthFactor::Basic.as_str()));

//         let public_key = "-----BEGIN PUBLIC KEY-----\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAuvzpR/gruC+W/JAy7amw\nchCOaM7U/pUuMLy6JcE+Y8GTtbVqUi8MX+JeJOdEa/H6o2v99lJtUfYFdpU5cman\nfn38h7bDSw+EsqPFgmO4RrASTHiPJ+s8FU/3SbV5tguSBTOEmbiTc5x0IAAmlrLs\nAwUHEypz9ug+OIWQt0YAoYBfApTq8rV+TaYe5NxL2hbtFKZemcIGxfn3mgn6B2Rs\nZeOOnCB661MXBYPJl2+j2HwbF3pWHZZUCXKB7t5krPJScAlEFAZsDCR4Gkzu0tF/\nm+F7cId3sTBGX2Ci1FrqctfXbfzLv2BTIbKg+4YyCgX3Hr+XfqI4tEuGK7wb3zMg\nBmr7d6Kuwf5VHDIBifu31vZ6w2Z6JzUFpeL7FJGeFjEZ4xk+mvVdG9uC3W9vYrcR\nHZ1CMllMGDs+8Y6BVdYFgFwYt/ht53vij4psSXIewdiBignUSiuC5BGRUpEtNhJq\niKDsHZmjtCwsscP+XhaBwALLI7JFvdq8ELMP4SwxFILGbWmArs9+lOfavnux3zf/\nyWKt5OcKmZL/Ns2o46+Q5PIIMU53XyMSuDXz70QKib9yNRswJj/lMX/+j1JiprHw\nMW3UiFMz45QJ7FFAGsN542GNXQhKQ9Z86rwUT04GQ5ArlUO1PnhIWFZaYrCoogYS\n1tpQMyInFq8zBypTJnh5iTUCAwEAAQ==\n-----END PUBLIC KEY-----";
//         assert!(client_auth.clone().update(AuthUpdate::PublicKey,&public_key));
//         assert!(client_auth.clone().update(AuthUpdate::Factors,AuthFactor::Signature.as_str()));


//         let read_client = ClientAuth::read(&client_auth.clone().uid).unwrap();
//         // println!("{:#?}", read_client.clone());

//         assert_eq!(
//             get_uid_from(&read_client.clone().apikey).unwrap(),
//             read_client.clone().uid
//         );
//         // assert_eq!(read_client.clone().delete(),true);
        
//         println!("{:#?}", read_client.clone());
   
//         read_client.delete();
//         let delete_status = match ClientAuth::read(&read_client.uid){
//             Some(item)=>{
//                 println!("{:?}",item);
//                 false
//             },
//             None=>true
//         };

//         assert!(delete_status);
//     }
//     // Careful with that axe, Eugene
//     /// This must always be ignored on master or it will delete all your stuff    
 
 
// }
