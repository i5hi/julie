use crate::lib::aes;
use crate::lib::hash;
use crate::lib::database;

use serde::{Deserialize, Serialize};
use std::str;

use std::str::FromStr;

use uuid::Uuid;


#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AuthFactor{
    /// ApiKey is factor 0, when a random new uid and apikey are generated by an admin and shared with a client to setup Basic auth.
    ApiKey,
    /// Basic signifies a username:pass256 set by the client (requires ApiKey).
    Email,
    /// Email auth is an alternative to basic auth which requires ada-postfix (requires ApiKey).
    Basic,
    /// Signature signifies a public_key is registered; requiring token requests to be signed by the client (requires Basic). 
    Signature,
    /// Totp is if a b32_key is verified by the client (requires Basic).
    Totp,
    /// All factors enabled.
    All,
}
impl AuthFactor {
    pub fn as_str(&self) -> &'static str {
        match *self {
            AuthFactor::ApiKey=>"ApiKey",
            AuthFactor::Email=>"Email",
            AuthFactor::Basic=>"Basic",
            AuthFactor::Signature=>"Signature",
            AuthFactor::Totp=>"Totp",
            AuthFactor::All=>"All"
        }
    }
}
impl FromStr for AuthFactor{
    type Err = ();

    fn from_str(s: &str) -> Result<AuthFactor,Self::Err>{
        let factor = match s {
            "ApiKey"=>AuthFactor::ApiKey,
            "Email"=>AuthFactor::Email,
            "Basic"=>AuthFactor::Basic,
            "Signature"=>AuthFactor::Signature,
            "Totp"=>AuthFactor::Totp,
            "All"=>AuthFactor::All,
            &_=>return Err(())
        };
        Ok(factor)
    }
}

/// ClientAuth is a database structure to store client authentication data.
//// The current implementation is very tightly coupled with sled db.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClientAuth {
    pub uid: String, // index
    pub apikey: String,
    pub salt: String,
    pub username: String,
    pub pass512: String,
    pub email : String,
    pub email_token: String,
    pub email_expiry: String,
    pub public_key: String,
    pub totp_key: String,
    pub factors: Vec<AuthFactor>,
}

pub enum AuthUpdate{
    ApiKey,
    Salt,
    Username,
    P512,
    Email,
    EmailToken,
    EmailExpiry,
    PublicKey,
    TotpKey,
    Factors
}


impl ClientAuth {
    /// Used by the admin to create a new client with a uid and apikey index.
    pub fn new() -> Self {

        // creating an alternative apikey index tree
        let new_client = ClientAuth {
            uid: format!("s5uid-{}", Uuid::new_v4()).to_string(),
            apikey: aes::keygen(aes::Encoding::Hex),
            salt: hash::create_salt(),
            email: "None".to_string(),
            email_token: "None".to_string(),
            email_expiry: "None".to_string(),
            username: "None".to_string(),
            pass512: "None".to_string(),
            public_key: "None".to_string(),
            totp_key: "None".to_string(),
            factors:vec![AuthFactor::ApiKey]
        };

        let root = database::get_root(database::CLIENT).unwrap();
        let main_tree = database::get_tree(root.clone(), &new_client.clone().uid).unwrap();
        let apikey_tree = database::get_tree(root.clone(), &new_client.clone().apikey).unwrap();

        // creating api index tree

        apikey_tree.insert(b"uid", new_client.clone().uid.as_bytes()).unwrap();
        apikey_tree.insert(b"apikey", new_client.clone().apikey.as_bytes()).unwrap();
        apikey_tree.flush().unwrap();

        // creating main tree
        root.flush().unwrap();
        let bytes = bincode::serialize(&new_client).unwrap();

        main_tree.insert("client", bytes).unwrap();
        main_tree.flush().unwrap();
        
        new_client

    }
    /// Get ClientAuth structure using apikey
    pub fn init(apikey: &str) -> Option<Self>{
        let uid = match get_uid_from(apikey){
            Some(uid)=>uid,
            None=> return None
        };

        match ClientAuth::read(&uid){
            Some(object)=> return Some(object),
            None=> return None
        };

    }
    /// Get a ClientAuth structure using uid
    pub fn read(uid: &str) -> Option<Self> {
        let root = database::get_root(database::CLIENT).unwrap();
        let main_tree = database::get_tree(root.clone(), uid).unwrap();

        // if this tree exists return it
        if main_tree.contains_key(b"client").unwrap() {

            match main_tree.get("client").unwrap() {
                Some(bytes) => {
                    let client: ClientAuth = bincode::deserialize(&bytes).unwrap();
                    Some(client)
                },
                None => None,
            }
            
        } else {
            root.drop_tree(&main_tree.name()).unwrap();
            None
        }
    }

    pub fn update(&self, key: AuthUpdate, value: &str)->bool{
        let mut updating_client = ClientAuth::read(&self.uid).unwrap();
        match key {
            AuthUpdate::ApiKey=> updating_client.apikey = value.to_string(),
            AuthUpdate::Salt=> updating_client.salt = value.to_string(),
            AuthUpdate::Username=> updating_client.username = value.to_string(),
            AuthUpdate::P512=> updating_client.pass512 = value.to_string(),
            AuthUpdate::Email=> updating_client.email = value.to_string(),
            AuthUpdate::EmailToken=> updating_client.email_token = value.to_string(),
            AuthUpdate::EmailExpiry=> updating_client.email_expiry = value.to_string(),
            AuthUpdate::PublicKey=> updating_client.public_key = value.to_string(),
            AuthUpdate::TotpKey=> updating_client.totp_key = value.to_string(),
            AuthUpdate::Factors=> {
                if updating_client.factors.contains(&AuthFactor::from_str(value).unwrap()){
                    return false
                }
                else{
                    updating_client.factors.push(AuthFactor::from_str(value).unwrap());
                }
            },
            _=>return false
        };
        let root = database::get_root(database::CLIENT).unwrap();
        let main_tree = database::get_tree(root.clone(), &self.clone().uid).unwrap();
        
        let bytes = bincode::serialize(&updating_client).unwrap();

        main_tree.insert("client", bytes).unwrap();
        main_tree.flush().unwrap();
        true
    }
    pub fn delete(&self)->bool{
        let root = database::get_root(database::CLIENT).unwrap();
        let main_tree = database::get_tree(root.clone(), &self.clone().uid).unwrap();
        let apikey_tree = database::get_tree(root.clone(), &self.clone().apikey).unwrap();

        main_tree.clear().unwrap();
        main_tree.flush().unwrap();
        root.drop_tree(&main_tree.name()).unwrap();
        apikey_tree.clear().unwrap();
        apikey_tree.flush().unwrap();
        root.drop_tree(&apikey_tree.name()).unwrap();

        root.flush().unwrap();

        true

    }

}

/// All methods use uid as the primary index. Incase only an apikey is presented, the uid index can be retrieved with this function.
fn get_uid_from(apikey: &str) -> Option<String> {
    let root = database::get_root(database::CLIENT).unwrap();
    let apikey_tree = database::get_tree(root.clone(), apikey).unwrap();

    if apikey_tree.contains_key(b"uid").unwrap() {
       Some(str::from_utf8(&apikey_tree.get(b"uid").unwrap().unwrap().to_vec()).unwrap().to_string())
    } else {
        root.drop_tree(&apikey_tree.name()).unwrap();
        None
    }

}

/// Retrives all tree indexes in a db
pub fn get_uid_indexes() -> Vec<String>{
    let root = database::get_root(database::CLIENT).unwrap();
    let mut uids: Vec<String> = [].to_vec();
    for key in root.tree_names().iter() {
        let uid = str::from_utf8(key).unwrap();
        if uid.starts_with("s5uid"){
            uids.push(uid.to_string());
        }
        else{

        };
    }
    uids
}
/// Removes all trees in a db. Careful with that axe, Eugene.
pub fn remove_client_trees() -> bool {
    let root = database::get_root(database::CLIENT).unwrap();
    for key in root.tree_names().iter() {
        let index = str::from_utf8(key).unwrap();
        let tree = database::get_tree(root.clone(),index).unwrap();
        // println!("Name: {:?}",str::from_utf8(&tree.name()).unwrap());
        tree.clear().unwrap();
        tree.flush().unwrap();
        if str::from_utf8(&tree.name()).unwrap() != "__sled__default" {
            root.drop_tree(&tree.name()).unwrap();
        }
        else{

        }

    }
    root.flush().unwrap();

    true
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lib::hash::{sha256,salted512};
    use std::fs::File;
    use std::io::prelude::*;


    #[test]
    fn client_composite() {
        // client asks admin to initialize a user account
        let client_auth = ClientAuth::new();
        // admin gives client this new client_auth with an apikey
        let indexes = get_uid_indexes();
        println!("#Clients: {}", indexes.len());
        println!("{:?}", indexes);

        // client then registers a username and password
        let username = "vmd";
        let password = "secret";
        // user must hash password
        let p256 = sha256(password);
        let pass256_expected =
            "2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b".to_string();
        
        assert_eq!(p256.clone(), pass256_expected.clone());

        // user must encode username:pass256 in base64
        let encoded = base64::encode(format!("{}:{}",username.clone(),p256.clone()).as_bytes());
        let encoded_expected = "dm1kOjJiYjgwZDUzN2IxZGEzZTM4YmQzMDM2MWFhODU1Njg2YmRlMGVhY2Q3MTYyZmVmNmEyNWZlOTdiZjUyN2EyNWI=";

        assert_eq!(encoded.clone(),encoded_expected.clone());
    
        // println!("{:#?}",client_auth.clone());
        assert!(client_auth.clone().update(AuthUpdate::Username,username));
        assert!(client_auth.clone().update(AuthUpdate::P512,&salted512(&p256,&client_auth.clone().salt)));
        assert!(client_auth.clone().update(AuthUpdate::Factors,AuthFactor::Basic.as_str()));

        let public_key = "-----BEGIN PUBLIC KEY-----\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAuvzpR/gruC+W/JAy7amw\nchCOaM7U/pUuMLy6JcE+Y8GTtbVqUi8MX+JeJOdEa/H6o2v99lJtUfYFdpU5cman\nfn38h7bDSw+EsqPFgmO4RrASTHiPJ+s8FU/3SbV5tguSBTOEmbiTc5x0IAAmlrLs\nAwUHEypz9ug+OIWQt0YAoYBfApTq8rV+TaYe5NxL2hbtFKZemcIGxfn3mgn6B2Rs\nZeOOnCB661MXBYPJl2+j2HwbF3pWHZZUCXKB7t5krPJScAlEFAZsDCR4Gkzu0tF/\nm+F7cId3sTBGX2Ci1FrqctfXbfzLv2BTIbKg+4YyCgX3Hr+XfqI4tEuGK7wb3zMg\nBmr7d6Kuwf5VHDIBifu31vZ6w2Z6JzUFpeL7FJGeFjEZ4xk+mvVdG9uC3W9vYrcR\nHZ1CMllMGDs+8Y6BVdYFgFwYt/ht53vij4psSXIewdiBignUSiuC5BGRUpEtNhJq\niKDsHZmjtCwsscP+XhaBwALLI7JFvdq8ELMP4SwxFILGbWmArs9+lOfavnux3zf/\nyWKt5OcKmZL/Ns2o46+Q5PIIMU53XyMSuDXz70QKib9yNRswJj/lMX/+j1JiprHw\nMW3UiFMz45QJ7FFAGsN542GNXQhKQ9Z86rwUT04GQ5ArlUO1PnhIWFZaYrCoogYS\n1tpQMyInFq8zBypTJnh5iTUCAwEAAQ==\n-----END PUBLIC KEY-----";
        assert!(client_auth.clone().update(AuthUpdate::PublicKey,&public_key));
        assert!(client_auth.clone().update(AuthUpdate::Factors,AuthFactor::Signature.as_str()));


        let read_client = ClientAuth::read(&client_auth.clone().uid).unwrap();
        // println!("{:#?}", read_client.clone());

        assert_eq!(
            get_uid_from(&read_client.clone().apikey).unwrap(),
            read_client.clone().uid
        );
        // assert_eq!(read_client.clone().delete(),true);
        
        println!("{:#?}", read_client.clone());
   
        read_client.delete();
        let delete_status = match ClientAuth::read(&read_client.uid){
            Some(item)=>{
                println!("{:?}",item);
                false
            },
            None=>true
        };

        assert!(delete_status);
    }
    // Careful with that axe, Eugene
    /// This must always be ignored on master or it will delete all your stuff    
    #[test] #[ignore]
    fn delete_all_clients(){
        let status = remove_client_trees();
        assert!(status);
        assert_eq!(get_uid_indexes().len(),0);

    }
 
}
